//------------------------------------------------------------------------------
/*
    This file is part of rippled: https://github.com/ripple/rippled
    Copyright (c) 2017 Ripple Labs Inc.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose  with  or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE  SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH  REGARD  TO  THIS  SOFTWARE  INCLUDING  ALL  IMPLIED  WARRANTIES  OF
    MERCHANTABILITY  AND  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY  SPECIAL ,  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER  RESULTING  FROM  LOSS  OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION  OF  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
//==============================================================================

#ifndef RIPPLE_CONDITIONS_DER_H
#define RIPPLE_CONDITIONS_DER_H

#include <ripple/basics/Buffer.h>
#include <ripple/basics/Slice.h>
#include <ripple/conditions/Types.h>

#include <algorithm>
#include <bitset>
#include <limits>
#include <stack>
#include <system_error>
#include <vector>

#include <boost/optional.hpp>

namespace ripple {
namespace cryptoconditions {
namespace der {

/**  Type of the group.

     @note Sometimes this matches the asn.1 tag number, but not always. In
     particular, a coder in "auto" mode may use different tags, and some of
     these types (`autoSequence`, `sequenceChild`, `choice`, and `fuzzRoot`)
     will never match the tag type. However, the coders need to know the
     additional information, such as when a parent group is a sequence, or an
     autoSequence.
*/

enum class GroupType {
    boolean = 1,
    integer = 2,
    bitString = 3,
    octetString = 4,
    null = 5,
    objectIdentifier = 6,
    real = 9,
    enumerated = 10,
    utf8String = 12,
    sequence = 16,
    set = 17,

    // The following are never tag ids.

    // a sequence that has auto generated tag numbers
    autoSequence = 252,
    // a child in an autogenerated sequence. This is useful as the parent when
    // the child is a "choice"
    sequenceChild = 253,
    choice = 254,
    // used in fuzz testing only
    fuzzRoot = 255
};

/** Error types for asn.1 der coders
 */
enum class Error {
    /// Integer would not fit in the bounds of the specified type
    integerBounds = 1,
    /** There is more content data in a group than expected. For example: after
        decoding a group, if there is more content is a slice.
     */  
    longGroup,
    /** There is less content data in a group than expected. For example: trying to
        decode a string of length 10 from a slice of length 9.
     */
    shortGroup,
    /// Encoding is not a valid der encoding
    badDerEncoding,
    /// This implementation only supports tag numbers that will fit in a
    /// std::uint64_t
    tagOverflow,
    /// A decoded preamble did not match an expected preamble
    preambleMismatch,
    /// A decoded contentLength did not match an expected contentLength
    contentLengthMismatch,
    /// Choice tag did not match a known type
    unknownChoiceTag,
    /// Supported by der, but not this implementation
    unsupported,
    /** Programming error. For example: detecting more pops than pushes on the
        group stack.
     */ 
    logicError
};

/** Convert an error enum to an std::error_code
 */
std::error_code
make_error_code(Error e);

/** asn.1 class ids
 */
enum class ClassId { universal, application, contextSpecific, priv };

/** The coder's tag mode.
 */
enum class TagMode {
    /** direct corresponds to asn.1's `explicit`. Tags will not be automatically assigned.

        @note `explicit` is a c++ keyword, so an alternate name must be used.
    */
    direct,
    /// Tags will be automatically assigned
    automatic
};

struct Encoder;
struct Decoder;

/** Interface for serializing and deserializing types into a der coder.

   Types that serialized into a der coder need to specialize a `DerCoderTraits`
   class and provide implementations of each of the member functions described
   in this unspecialized class.

   Specialized classes are provided for common C++ types, such as integers,
   strings, buffers, bitsets, etc.

   Since there are two types of collections in ans.1 - sets and sequences - some
   c++ collections like `std::vector` must be wrapped in the helper functions
   `make_sequence` or `make_set` so the coder knows which asn.1 collection type
   to use. `std::tuple` is always coded as an asn.1 sequence, since 100% of the
   cryptocondition use-cases serialized tuples as sequences.

   A typical user type is written as an asn.1 choice type, where each choice
   type is a asn.1 sequence. This would be implemented in C++ as a class
   hierarchy. Each concrete leaf class represents a choice. The trait is written
   in terms of a `unique_ptr` to the base class. When decoding, the choice is
   used to create the correct concrete leaf class, and the leaf class would
   serialize itself by using a `std::tuple` of each member of the sequence. For
   example `der_decoder >> std::tuple(member1, member2,...) >> der::eos;`
   Encoding is similar: the correct choice is written to the der stream, then
   the data members are serialized using a `std::tuple`. For example:
   `der_encoder << std::tuple(member1, member2,...) << der::eos;`. Since
   encoding and decoding are almost always exact copies, except decoding uses
   `operator>>` while encoding uses `operator<<`, the der encoders offer
   `operator&` which will decode when using a decoder, and encode with using an
   encoder (boost serialization library uses the same operator). Using this
   operator, both the encoder and decoder may be written as `coder &
   std::tuple(member1, member2,...) & der::eos;`.


   @note This unspecialized class should never be instantiated. If it is, a
         `static_assert` will fire. A specialized `DerCoderTraits` must be provided
         for each class that is to be serialized.
 */
template <class T>
struct DerCoderTraits
{
    static_assert(
        sizeof(T) == -1,
        "DerCoderTraits must be specialized for this type");

    /// ans.1 class id
    constexpr static ClassId
    classId();

    /// group type
    constexpr static GroupType
    groupType();

    /** ans.1 tag type, if known.

        The tagNum for choice types can only be known from the actual value being
        encoded. In these cases `boost::none` is returned.
    */ 
    static boost::optional<std::uint8_t> const&
    tagNum();

    /// ans.1 tag type for this given value.
    template <class TT>
    static std::uint8_t tagNum(TT);

    /** return true if this type is an asn.1 primitive. return false if this
        type is an asn.1 constructed type.
     */
    constexpr static bool
    primitive();

    /// return the number of bytes required to encode the value
    template <class TT>
    static size_t
    length(TT const& v);

    /// serialize the value into the encoder
    template <class TT>
    static void
    encode(Encoder& s, TT v);

    /// deserialize the value from the decoder
    template <class TT>
    static void
    decode(Decoder& decoder, TT& v);
};

/// constructor tag to specify an asn.1 sequence
struct SequenceTag {};
/// constructor tag to specify an asn.1 set
struct SetTag {};

/// the type information part of an asn.1 preamble
struct Tag
{
    ClassId classId = ClassId::universal;
    std::uint64_t tagNum = 0;
    bool primitive = true;

    Tag() = default;
    Tag(Type t);

    Tag(ClassId classId_, std::uint64_t tagNum_, bool primitive_)
        : classId(classId_), tagNum(tagNum_), primitive(primitive_)
    {
    }

    template <class T>
    Tag(DerCoderTraits<T> t, std::uint64_t tn)
        : Tag(DerCoderTraits<T>::classId(), tn, DerCoderTraits<T>::primitive())
    {
    }

    Tag(SequenceTag);

    Tag(SetTag);

    /// return true if the tag represents an asn.1 set
    bool
    isSet() const;

    friend bool
    operator<(Tag const& lhs, Tag const& rhs)
    {
        return std::tie(lhs.classId, lhs.tagNum, lhs.primitive) <
            std::tie(rhs.classId, rhs.tagNum, rhs.primitive);
    }
    friend bool
    operator==(Tag const& lhs, Tag const& rhs)
    {
        return lhs.classId == rhs.classId && lhs.tagNum == rhs.tagNum &&
            lhs.primitive == rhs.primitive;
    }
    friend bool
    operator!=(Tag const& lhs, Tag const& rhs)
    {
        return !operator==(lhs, rhs);
    }
};

/** an ans.1 preamble

    values are encoded in ans.1 with a preamble that specifies how to interpret
    the content, followed by the content. This struct represents the preamble.
*/
struct Preamble
{
    /// type information
    Tag tag_;
    /// content length in bytes
    std::uint64_t contentLength_;
};

/** RAII class for coder groups

    asn.1 values are coded as a hierarchy. There are root values, which have
    sub-values as children. A `GroupGuard` organizes the serialization code so
    C++ scopes represent levels in the asn.1 hierarchy. The constructor pushes a
    new group onto the coders group stack, and the destructor pops the group.
    Entering a scope represents a new value that will be coded. New values will
    be descendants of this value coded in this scope until the scope is exited.
 */
template <class Coder>
class GroupGuard
{
    /// The encoder or decoder
    Coder& s_;

public:
    explicit
    GroupGuard(Coder& s, Tag t, GroupType bt)
        : s_(s)
    {
        s_.startGroup(t, bt);
    }

    explicit
    GroupGuard(Coder& s, boost::optional<Tag> const& t, GroupType bt)
        : s_(s)
    {
        s_.startGroup(t, bt);
    }

    explicit
    GroupGuard(Coder& s, SequenceTag t)
        : GroupGuard(s, Tag{t}, GroupType::sequence)
    {
    }

    explicit
    GroupGuard(Coder& s, SetTag t)
        : GroupGuard(s, Tag{t}, GroupType::set)
    {
    }

    template <class T>
    explicit
    GroupGuard(Coder& s, DerCoderTraits<T> t)
        : s_(s)
    {
        boost::optional<Tag> tag;
        if (auto const tagNum = t.tagNum())
            tag.emplace(t, *tagNum);
        s_.startGroup(tag, t.groupType());
    }

    template <class T>
    explicit
    GroupGuard(Coder& s, T const& v, DerCoderTraits<T> t)
        : s_(s)
    {
        auto const tagNum = t.tagNum(v);
        Tag tag(t, tagNum);
        s_.startGroup(tag, t.groupType());
    }

    // Needed for fuzz testing
    explicit
    GroupGuard(Coder& s, GroupType bt)
        : s_(s)
    {
        s_.startGroup(boost::none, bt);
    }

    ~GroupGuard()
    {
        s_.endGroup();
    }
};

/** End of stream guard

    Coders need to know when when a serialization is complete. Clients signal
    this by calling `eos`. This guard calls `eos` in the destructor so leaving
    a scope may be used to signal `eos`.

    @note: This class is mostly used for testing. The usual way to signal `eos`
    is by adding `der::eos` at the end of a stream. For example: `coder << value
    << der::eos;`
 */
template <class Coder>
class EosGuard
{
    // Encoder or decoder
    Coder& s_;

public:
    explicit
    EosGuard(Coder& s)
        : s_(s)
    {
    }

    ~EosGuard()
    {
        s_.eos();
    }
};

/** Encode the integer in a format appropriate for an ans.1 tag number.

    Encode the integer in big endian form, in as few of bytes as possible. All
    but the last byte has the high order bit set. The number is encoded in base
    128 (7-bits each).
*/
void
encodeTagNum(std::vector<char>& dst, std::uint64_t v);

/** Encode the integer in a format appropriate for an ans.1 content length

    Encode the integer in big endian form, in as few of bytes as possible.
*/
void
encodeContentLength(std::vector<char>& dst, std::uint64_t v);

/** A value in a hierarchy of values when encoding

    asn.1 values are coded as a hierarchy. There is one root value, which has
    sub-values as children. When encoding, this class keeps track the type that
    is being encoded, what bytes in the stream represent content for this value,
    and child values.

    @note: decoders use a different class to represent the hierarchy of values.
 */
class Group
{
    /// asn.1 type information for the value being encoded
    Tag id_;
    /** position (in bytes) of the start of the contents of the value

        @note: this does not indicate the start of the preamble; the size of the
        preamble cannot be known until the size of the contents is known.
    */
    std::size_t start_;
    /// position (in bytes) of one past the end of the contents of the value
    std::size_t end_;
    /// subvalues of this value
    std::vector<Group> children_;
    /** The type and length information of the value.

        @note: the length of the preamble depends on the length of the content, so
               it cannot be calculated until all the value have been encoded. It is
               calculated when the group is popped off the encoders group stack.
     */
    std::vector<char> preamble_;
    /// asn.1 explicit (direct) or automatic tagging
    TagMode tagMode_;
    /// additional type information for the group
    GroupType groupType_;

    /** cache of the serialization

        asn.1 sets must be output in sorted order. When serializing the children
        of a group that represents a set, the serialization will be cached.
        Since sets can have children that are also sets, this prevents
        serializing the "leaf" sets multiple times.
    */
    mutable std::vector<char> cache_;
    std::vector<char>&
    cache(std::vector<char> const& src) const;

public:
    Group(Group const&) = default;
    Group(Group&&) = default;
    Group&
    operator=(Group&&) = default;
    Group&
    operator=(Group const&) = default;

    Group(
        Tag t,
        std::size_t s,
        TagMode tagMode,
        GroupType groupType);

    /// size in bytes of the preambles of all the children
    size_t
    childPreambleSize() const;

    /** size in bytes of all the preambles

        Size of this value's preamble plus the size of the preambles of all the
        children.
    */
    size_t
    totalPreambleSize() const;

    /** position (in bytes) of the start of the contents of the value

        @see {@link #start_}
     */
    size_t
    start() const;

    /** position (in bytes) of one past the end of the contents of the value

        @see {@link #end_}
     */
    size_t
    end() const;

    /// set the position for one past the end of the contents of the value
    void
    end(std::size_t e);

    /** total size in bytes of the group

        Size of the contents plus the size of all the preambles
     */
    size_t
    size() const;

    /** calculate the preamble

        @note: the length of the preamble depends on the length of the content, so
               it cannot be calculated until all the value have been encoded. It is
               calculated when the group is pop-ed off the encoders group stack.
     */
    void
    calcPreamble();

    /** write the preambles and contents

        @param src the serialized contents (not including the preambles)
        @param dst the destination to write the preambles and serialized contents
     */
    void
    write(std::vector<char> const& src, std::vector<char>& dst) const;

    /** create a group as a child of this group

        @param c parameters for the constructor of the subgroup
     */
    template <class... C>
    void
    emplaceChild(C&&... c)
    {
        children_.emplace_back(std::forward<C>(c)...);
    }

    /// return true if the group represents an asn.1 set
    bool
    isSet() const;

    /** return true if the group represents an auto sequence

        @note an auto sequence is an asn.1 sequence that has autogenerated
              tag numbers
     */
    bool
    isAutoSequence() const;

    /// return true if the group represents an asn.1 choice
    bool
    isChoice() const;

    /** set the groups type information

        @param primitive true is primitive, false if constructed
        @param bt the groups type information
     */
    void
    setPrimitiveAndType(bool primitive, GroupType bt);

    /// return the number of sub-values
    size_t
    numChildren() const;
};

/// encode the preamble from p into dst
void
encodePreamble(std::vector<char>& dst, Preamble const& p);

/// decode the preamble from slice into p
void
decodePreamble(Slice& slice, Preamble& p, std::error_code& ec);

/** type representing and end of stream

    Coders need to know when when a serialization is complete. Clients signal
    this by calling `eos`. The typical way of calling `eos` is by serializing a
    value of type Eos. There is a convenience global variable for this purpose.
    It will typically be used as follows: `coder << value << der::eos;`
*/
struct Eos {};
extern Eos eos;
/// constructor tag to specify a decoder in automatic mode
struct Automatic {};
extern Automatic automatic;
/** constructor tag to specify a type is being constructed for decoding into

    Often, it is convenient to create a type and then decode into that type.
    However, this would usually require that type to be default constructable
    (as the contents used to create are deserialized after the variable is
    constructed). This `Constructor` type is used to create constructors and
    specify that they should only be used for der decoding.
 */
struct Constructor {};
extern Constructor constructor;

/** Stream interface to encode values into asn.1 der format

    The encoder class has an interface similar to a c++ output stream. Values
    are added to the stream using the `<<` operator. After all the values are
    added to the encoder, it must be terminated with a call to `eos()`. As a
    convenience, there is a special variable called `eos` that when streamed will
    call the streams `eos()` function. Typically, the code to encode values to a
    stream is: `encoder << value_1 << ... << value_n << eos;`.

    Every type to be streamed must specialize the DerCoderTraits class @see
    {@link #DerCoderTraits}. There exist specializations for some C++ types and
    primitive rippled types - including integers, strings, bitstrings, tuples,
    buffers, arrays, and wrappers for wrapping collections like vector into
    either asn.1 sets or sequences.

    After the values are written, the stream should be checked for errors. The
    function `ec` will return the error code of the first error encountered
    while streaming. Streaming will stop after the first error.

    Once the values are streamed, the actual encoding is retrieved by calling
    the `write` function.

    Encoding and decoding values often have the same code structure. The only
    difference is encoding will use `operator<<` and decoding will use
    `operator>>`. To allow writing generic code, both encoders and decoders
    support `operator&`. Typically, the generic code both encode and decode is:
    `coder & value_1 & ... & value_n & eos;`
 */
struct Encoder
{
    /// explicit or automatic tagging
    TagMode tagMode_ = TagMode::direct;
    /// buffer to write value contents into
    std::vector<char> buf_;
    /** values are coded as a hierarchy. `subgroups_` tracks the current
        position in the hierarchy.

        The bottom of the stack is the root value, the top of the stack is the
        current parent.
     */
    std::stack<Group> subgroups_;
    /** Collection of root objects.

        @note Typically there will only be one root object.
    */
    std::vector<Group> roots_;

    /** the error code of the first error encountered

        @note after the error code is set encoding stops
     */
    std::error_code ec_;
    /** true if the `eos` function has been called

        some error handling cannot happen until all the values have been coded.
        `atEos_` ensures every stream is terminated with an `eos` call so those
        error checks can be run.
     */
    bool atEos_ = false;

    explicit
    Encoder(TagMode tagMode);
    ~Encoder();

    /// prepare to add a new value as a child of the current value
    void
    startGroup(Tag t, GroupType groupType);

    /// finish adding the new value
    void
    endGroup();

    /** terminate the stream

        Streams must be terminated before the destructor is called. Certain error checks
        cannot occur until the encoder knows streaming is complete. Calling `eos()` runs these
        error checks. Failing to call `eos` before the destructor is an error.
     */
    void
    eos();

    /// total size in bytes of the content and all the preambles
    size_t
    size() const;

    /** return the first error code encountered

        ec should be checked after streaming to ensure no errors occurred
     */
    std::error_code const&
    ec() const;

    /** write values encoded as asn.1 der into the dst buffer

        @param dst the destination to write the preambles and serialized contents
     */
    void
    write(std::vector<char>& dst) const;

    /** return true if the group at the top of the stack represents an auto
        sequence

        @note an auto sequence is an asn.1 sequence that has autogenerated
              tag numbers
     */
    bool
    parentIsAutoSequence() const;

    /** return true if the group at the top of the stack represents an asn.1
        choice
     */ 
    bool
    parentIsChoice() const;

    /** Add values to the encoder
    @{
    */
    friend
    Encoder&
    operator&(Encoder& s, Preamble const& p)
    {
        encodePreamble(s.buf_, p);
        return s;
    }
    friend
    Encoder&
    operator&(Encoder& s, Preamble& p)
    {
        encodePreamble(s.buf_, p);
        return s;
    }

    friend
    Encoder&
    operator&(Encoder& s, Eos e)
    {
        s.eos();
        return s;
    }

    template <class T>
    friend
    Encoder&
    operator&(Encoder& s, T&& v)
    {
        if (s.ec_)
            return s;

        using traits = DerCoderTraits<std::decay_t<T>>;
        auto const groupType = traits::groupType();

        if (s.parentIsAutoSequence())
        {
            if (groupType == GroupType::choice)
            {
                Tag const tag1{ClassId::contextSpecific,
                               s.subgroups_.top().numChildren(),
                               traits::primitive()};
                GroupGuard<Encoder> g1(s, tag1, GroupType::sequenceChild);
                if (s.ec_)
                    return s;
                Tag const tag2{traits{}, traits::tagNum(v)};
                GroupGuard<Encoder> g2(s, tag2, groupType);
                if (s.ec_)
                    return s;
                traits::encode(s, std::forward<T>(v));
            }
            else
            {
                Tag const tag{ClassId::contextSpecific,
                              s.subgroups_.top().numChildren(),
                              traits::primitive()};
                GroupGuard<Encoder> g(s, tag, groupType);
                if (s.ec_)
                    return s;
                traits::encode(s, std::forward<T>(v));
            }
        }
        else
        {
            Tag const tag{traits{}, traits::tagNum(v)};
            GroupGuard<Encoder> g(s, tag, groupType);
            if (s.ec_)
                return s;
            traits::encode(s, std::forward<T>(v));
        }

        return s;
    }

    template <class T>
    friend Encoder&
    operator<<(Encoder& s, T&& t)
    {
        return s & std::forward<T>(t);
    }
    /** @} */
};

/** Stream interface to decode values from asn.1 der format

    The decode class has an interface similar to a c++ output stream. Values are
    decoded from the stream using the `>>` operator. After all the values are
    decoded, it must be terminated with a call to `eos()`. As a convenience, there
    is a special variable called `eos` that when streamed will call the streams
    `eos()` function. Typically, the code to encode values to a stream is:
    `decoder >> value_1 >> ... >> value_n >> eos;`.

    Every type to be streamed must specialize the DerCoderTraits class @see
    {@link #DerCoderTraits}. There exist specializations for some C++ types and
    primitive rippled types - including integers, strings, bitstrings, tuples,
    buffers, arrays, and wrappers for wrapping collections like vector into
    either asn.1 sets or sequences.

    After the values are decoded, the stream should be checked for errors. The
    function `ec` will return the error code of the first error encountered
    while decoding. Decoding will stop after the first error.

    Encoding and decoding values often have the same code structure. The only
    difference is encoding will use `operator<<` and decoding will use
    `operator>>`. To allow writing generic code, both encoders and decoders
    support `operator&`. Typically, the generic code both encode and decode is:
    `coder & value_1 & ... & value_n & eos;`
 */
struct Decoder
{
    /** explicit or automatic tagging

        @note this must match the mode the values were encoded with
     */
    TagMode tagMode_;
    /** true if the `eos` function has been called

        some error handling cannot happen until all the values have been coded.
        `atEos_` ensures every stream is terminated with an `eos` call so those
        error checks can be run.
     */
    bool atEos_ = false;

    /// slice for the entire buffer to be decoded
    Slice rootSlice_;
    /** values are coded as a hierarchy. `ancestors_` tracks the current
        position in the hierarchy.

        The bottom of the stack is the root value, the top of the stack is the
        current parent.

        The tuple contains the slice, ancestor tag, groupType, and number of children
     */
    std::stack<std::tuple<Slice, Tag, GroupType, std::uint32_t>> ancestors_;

    /** the error code of the first error encountered

        @note after the error code is set decoding stops
     */
    std::error_code ec_;

    Decoder() = delete;
    explicit
    Decoder(Slice slice, TagMode tagMode);
    ~Decoder();

    /// prepare to decode a value as a child of the current value
    void
    startGroup(boost::optional<Tag> const& t, GroupType groupType);

    /// finish decoding the new value
    void
    endGroup();

    /** terminate the stream

        Streams must be terminated before the destructor is called. Certain error checks
        cannot occur until the encoder knows streaming is complete. Calling `eos()` runs these
        error checks. Failing to call `eos` before the destructor is an error.
     */
    void
    eos();

    /** return the first error code encountered

        ec should be checked after streaming to ensure no errors occurred
     */
    std::error_code const&
    ec() const;

    /** return the tag at the top of the ancestors stack

        return boost::none if the stack is empty
     */
    boost::optional<Tag>
    parentTag() const;

    /** return true if the ancestor at the top of the stack represents an auto
        sequence

        @note an auto sequence is an asn.1 sequence that has autogenerated
              tag numbers
     */
    bool
    parentIsAutoSequence() const;

    /** return true if the ancestor at the top of the stack represents an asn.1
        choice
     */ 
    bool
    parentIsChoice() const;

    /// return the portion of the buffer that represents the parent value
    Slice&
    parentSlice();

    /** Decode values from the encoder into variables
    @{
    */
    friend
    Decoder&
    operator&(Decoder& s, Eos e)
    {
        s.eos();
        return s;
    }

    friend
    Decoder&
    operator&(Decoder& s, Preamble& p)
    {
        if (s.ec_)
            return s;

        decodePreamble(s.parentSlice(), p, s.ec_);
        return s;
    }

    // The forwarding ref is needed here to support std::tie, SetWrapper, and
    // SequenceWrapper
    // (i.e. `s >> make_set(some_vec)`)
    template <class T>
    friend
    Decoder&
    operator&(Decoder& s, T&& v)
    {
        if (s.ec_)
            return s;

        using traits = DerCoderTraits<std::decay_t<T>>;
        auto const groupType = traits::groupType();
        if (s.parentIsAutoSequence())
        {
            if (groupType == GroupType::choice)
            {
                auto& numChildren = std::get<std::uint32_t>(s.ancestors_.top());
                Tag const tag1{
                    ClassId::contextSpecific, numChildren++, traits::primitive()};
                GroupGuard<Decoder> g1(s, tag1, GroupType::sequenceChild);
                if (s.ec_)
                    return s;
                boost::optional<Tag> tag2;
                if (auto const tagNum = traits::tagNum())
                    tag2.emplace(traits{}, *tagNum);
                GroupGuard<Decoder> g2(s, tag2, groupType);
                if (s.ec_)
                    return s;
                traits::decode(s, v);
            }
            else
            {
                auto& numChildren = std::get<std::uint32_t>(s.ancestors_.top());
                Tag const tag{
                    ClassId::contextSpecific, numChildren++, traits::primitive()};
                GroupGuard<Decoder> g(s, tag, groupType);
                if (s.ec_)
                    return s;
                traits::decode(s, v);
            }
        }
        else
        {
            boost::optional<Tag> tag;
            if (auto const tagNum = traits::tagNum())
                tag.emplace(traits{}, *tagNum);
            GroupGuard<Decoder> g(s, tag, groupType);
            if (s.ec_)
                return s;
            traits::decode(s, v);
        }

        return s;
    }

    template <class T>
    friend Decoder&
    operator>>(Decoder& s, T&& t)
    {
        return s & std::forward<T>(t);
    }
    /** @} */

    /// helper function for fuzz testing
    void
    fuzzTest();
};

/** base class for DerCoderTraits for integer types

    @see {@link #DerCoderTraits}
*/
struct IntegerTraits
{
    constexpr static ClassId
    classId()
    {
        return ClassId::universal;
    }

    constexpr static GroupType
    groupType()
    {
        return GroupType::integer;
    }

    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{2};
        return tn;
    }

    template <class T>
    static std::uint8_t tagNum(T)
    {
        return 2;
    }

    constexpr static bool
    primitive()
    {
        return true;
    }

    template <class T>
    static size_t
    length(T const& v)
    {
        const auto isSigned = std::numeric_limits<T>::is_signed;
        if (!v || (isSigned && v == -1))
            return 1;

        std::size_t n = sizeof(v);
        signed char toSkip = (isSigned && v < 0) ? 0xff : 0;
        // skip leading 0xff for negative signed, otherwise skip leading zeros
        // when skipping 0xff, the next octet's high bit must be set
        // when skipping 0, the first octet's high bit must not be set
        while (n--)
        {
            auto const c = static_cast<signed char>((v >> (n * 8)) & 0xff);
            if (c == toSkip &&
                !(isSigned && v < 0 && n &&
                  (static_cast<signed char>((v >> ((n - 1) * 8)) & 0xff) >= 0)))
                continue;

            if (v > 0 && c < 0)
                return n + 2;
            else
                return n + 1;
        }
        assert(0);  // will never happen
        return 1;
    }

    template <class T>
    static void
    encode(Encoder& s, T v)
    {
        std::vector<char>& dst = s.buf_;

        if (!v)
        {
            dst.push_back(0);
            return;
        }

        std::size_t n = length(v);
        while (n--)
        {
            if (n >= sizeof(T))
                dst.push_back(static_cast<char>(0));
            else
                dst.push_back(static_cast<char>((v >> (n * 8)) & 0xFF));
        }
    }

    template <class T>
    static void
    decode(Decoder& decoder, T& v)
    {
        auto& slice = decoder.parentSlice();
        std::error_code& ec = decoder.ec_;

        if (slice.empty())
        {
            // can never have zero sized integers
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        const bool isSigned = std::numeric_limits<T>::is_signed;
        // unsigned types may have a leading zero octet
        const size_t maxLength = isSigned ? sizeof(T) : sizeof(T) + 1;
        if (slice.size() > maxLength)
        {
            ec = make_error_code(Error::integerBounds);
            return;
        }

        if (!isSigned && (slice[0] & (1 << 7)))
        {
            // trying to decode a negative number into a positive value
            ec = make_error_code(Error::integerBounds);
            return;
        }

        if (!isSigned && slice.size() == sizeof(T) + 1 && slice[0])
        {
            // since integers are coded as two's complement, the first byte may
            // be zero for unsigned reps
            ec = make_error_code(Error::integerBounds);
            return;
        }

        v = 0;
        for (size_t i = 0; i < slice.size(); ++i)
            v = (v << 8) | (slice[i] & 0xff);

        if (isSigned && (slice[0] & (1 << 7)))
        {
            for (int i = slice.size(); i < sizeof(T); ++i)
                v |= (T(0xff) << (8 * i));
        }
        slice += slice.size();
    }
};

template <>
struct DerCoderTraits<std::uint8_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::uint16_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::uint32_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::uint64_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int8_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int16_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int32_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int64_t> : IntegerTraits
{
};

/** base class for DerCoderTraits for types that will be coded as asn.1 octet
    strings

    @see {@link #DerCoderTraits}

    @note this includes std::string and std::array<std::uintt_t, N>, and Buffer
*/
struct OctetStringTraits
{
    constexpr static ClassId
    classId()
    {
        return ClassId::universal;
    }

    constexpr static GroupType
    groupType()
    {
        return GroupType::octetString;
    }

    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{4};
        return tn;
    }

    template <class T>
    static std::uint8_t
    tagNum(T const&)
    {
        return 4;
    }

    constexpr static bool
    primitive()
    {
        return true;
    }

protected:
    static void
    encode(Encoder& encoder, Slice s)
    {
        if (s.empty())
            return;

        std::vector<char>& dst = encoder.buf_;

        auto const dstIdx = dst.size();
        dst.resize(dst.size() + s.size());
        memcpy(&dst[dstIdx], s.data(), s.size());
    }

    static void
    decode(Decoder& decoder, void* dstData, std::size_t dstSize)
    {
        auto& slice = decoder.parentSlice();
        std::error_code& ec = decoder.ec_;

        if (dstSize != slice.size())
        {
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        if (!slice.empty())
            memcpy(dstData, slice.data(), slice.size());

        slice += slice.size();
    }
};

template <>
struct DerCoderTraits<std::string> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, std::string const& s)
    {
        OctetStringTraits::encode(encoder, makeSlice(s));
    }

    static void
    decode(Decoder& decoder, std::string& v)
    {
        auto& slice = decoder.parentSlice();
        v.resize(slice.size());
        if (!v.empty())
            OctetStringTraits::decode(decoder, &v[0], v.size());
    }
};

template <std::size_t S>
struct DerCoderTraits<std::array<std::uint8_t, S>> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, std::array<std::uint8_t, S> const& s)
    {
        OctetStringTraits::encode(encoder, makeSlice(s));
    }

    static void
    decode(Decoder& decoder, std::array<std::uint8_t, S>& v)
    {
        OctetStringTraits::decode(decoder, v.data(), v.size());
    }
};

template <>
struct DerCoderTraits<Buffer> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, Buffer const& b)
    {
        OctetStringTraits::encode(encoder, b);
    }

    static void
    decode(Decoder& decoder, Buffer& v)
    {
        auto& slice = decoder.parentSlice();
        v.alloc(slice.size());
        if (!v.empty())
            OctetStringTraits::decode(decoder, v.data(), v.size());
    }
};

/** Wrapper for a size constrained der OctetString

    The size of the string must be equal to the specified constraint.
 */
template <class T>
struct OctetStringCheckEqualSize
{
    T& col_;
    std::size_t constraint_;
    OctetStringCheckEqualSize(T& col, std::size_t s) : col_{col}, constraint_{s}
    {
    }
};

/** Wrapper for a size constrained der OctetString

    The size of the string must be less than the specified constraint.
 */
template <class T>
struct OctetStringCheckLessSize
{
    T& col_;
    std::size_t constraint_;
    OctetStringCheckLessSize(T& col, std::size_t s) : col_{col}, constraint_{s}
    {
    }
};

/** convenience function to create an equal-size constrained octet string

    @note the template parameter T must be one of the types OctetStringTraits is
          specialized on. @see {@link #OctetStringTraits}
*/
template <class T>
OctetStringCheckEqualSize<T>
make_octet_string_check_equal(T& t, std::size_t s)
{
    return OctetStringCheckEqualSize<T>(t, s);
}

/** convenience function to create a "less size" constrained octet string

    @note the template parameter T must be one of the types OctetStringTraits is
          specialized on. @see {@link #OctetStringTraits}
*/
template <class T>
OctetStringCheckLessSize<T>
make_octet_string_check_less(T& t, std::size_t s)
{
    return OctetStringCheckLessSize<T>(t, s);
}

/** DerCoderTraits for types that will be coded as "equal size" constrained
    asn.1 octet strings

    @see {@link #DerCoderTraits}
    @see {@link #make_octet_string_check_equal}
*/
template <class T>
struct DerCoderTraits<OctetStringCheckEqualSize<T>> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, OctetStringCheckEqualSize<T> const& v)
    {
        DerCoderTraits<T>::encode(encoder, v.col_);
    }

    static void
    decode(Decoder& decoder, OctetStringCheckEqualSize<T>& v)
    {
        auto& slice = decoder.parentSlice();
        if (slice.size() != v.constraint_)
        {
            decoder.ec_ = make_error_code(Error::contentLengthMismatch);
            return;
        }
        DerCoderTraits<T>::decode(decoder, v.col_);
    }
};

/** DerCoderTraits for types that will be coded as "less size" constrained asn.1
    octet strings

    @see {@link #DerCoderTraits}
*/
template <class T>
struct DerCoderTraits<OctetStringCheckLessSize<T>> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, OctetStringCheckLessSize<T> const& v)
    {
        DerCoderTraits<T>::encode(encoder, v.col_);
    }

    static void
    decode(Decoder& decoder, OctetStringCheckLessSize<T>& v)
    {
        auto& slice = decoder.parentSlice();
        if (slice.size() > v.constraint_)
        {
            // Return unsupported rather than contentLengthMismatch
            // because this constraint is an implementation limit rather
            // than a parser constraint
            decoder.ec_ = make_error_code(Error::unsupported);
            return;
        }
        DerCoderTraits<T>::decode(decoder, v.col_);
    }
};

/** DerCoderTraits for std::bitset

    bitsets will be coded as ans.1 bitStrings

    @see {@link #DerCoderTraits}
    @see {@link #make_octet_string_check_less}
*/
template <std::size_t S>
struct DerCoderTraits<std::bitset<S>>
{
    constexpr static std::uint8_t mod8 = S % 8;
    constexpr static std::uint8_t const minUnusedBits = mod8 ? 8 - mod8 : 0;
    constexpr static std::uint8_t const maxBytes = mod8 ? 1 + S / 8 : S / 8;

    constexpr static GroupType
    groupType()
    {
        return GroupType::bitString;
    }

    constexpr static ClassId
    classId()
    {
        return ClassId::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{3};
        return tn;
    }
    static std::uint8_t
    tagNum(std::bitset<S> const&)
    {
        return 3;
    }
    constexpr static bool
    primitive()
    {
        return true;
    }

    static std::uint8_t
    reverseBits(std::uint8_t b)
    {
        static constexpr std::uint8_t lut[256] = 
        {
          0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 
          0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 
          0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 
          0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 
          0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2, 
          0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
          0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 
          0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
          0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
          0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 
          0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
          0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
          0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 
          0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
          0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 
          0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
        };
        return lut[b];
    }

    static void
    encode(Encoder& encoder, std::bitset<S> const& s)
    {
        std::vector<char>& dst = encoder.buf_;
        dst.reserve(
            dst.size() + 1 + maxBytes);  // +1 for encoding the unusedBits

        static_assert(
            maxBytes > 0 && maxBytes <= sizeof(unsigned long),
            "Unsupported bitset size");
        auto const bits = s.to_ulong();

        if (bits == 0)
        {
            dst.push_back(7);
            dst.push_back(0);
            return;
        }

        std::size_t const leadingZeroBytes = [&] {
            std::size_t result = 0;
            auto curByteIndex = maxBytes;
            while (curByteIndex--)
            {
                std::uint8_t const b = (bits >> curByteIndex * 8) & 0xff;
                if (b)
                    return result;
                ++result;
            }
            return result;
        }();

        std::uint8_t const unusedBits = [&] {
            // b is first non-zero byte
            std::uint8_t const b =
                (bits >> (maxBytes - leadingZeroBytes - 1) * 8) & 0xff;
            if (b & 0x80)
                return 0;
            if (b & 0x40)
                return 1;
            if (b & 0x20)
                return 2;
            if (b & 0x10)
                return 3;
            if (b & 0x08)
                return 4;
            if (b & 0x04)
                return 5;
            if (b & 0x02)
                return 6;
            if (b & 0x01)
                return 7;
            return 8;
        }();

        dst.push_back(unusedBits);

        for (size_t curByte = 0; curByte < maxBytes - leadingZeroBytes; ++curByte)
        {
            uint8_t const v = (bits >> curByte * 8) & 0xff;
            dst.push_back(reverseBits(v));
        }
    }

    static void
    decode(Decoder& decoder, std::bitset<S>& v)
    {
        auto& slice = decoder.parentSlice();
        std::error_code& ec = decoder.ec_;

        if (slice.size() > maxBytes + 1)
        {
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        auto const unused = slice[0];
        slice += 1;

        if (unused < minUnusedBits)
        {
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        if (unused >= 8)
        {
            ec = make_error_code(Error::badDerEncoding);
            return;
        }

        static_assert(
            maxBytes > 0 && maxBytes <= sizeof(unsigned long),
            "Unsupported bitset size");
        unsigned long bits = 0;
        auto const numBytes = slice.size();
        for (size_t curByteIndex = 0; curByteIndex < numBytes; ++curByteIndex)
        {
            std::uint8_t const curByte = reverseBits(slice[0]);
            bits |= curByte << (curByteIndex * 8);
            slice += 1;

            if ((curByteIndex == numBytes - 1) && unused)
            {
                // check last byte for correct zero padding
                std::uint8_t const mask = 0xff & ~((1 << (8 - unused)) - 1);
                if (curByte & mask)
                {
                    // last byte has incorrect padding
                    ec = make_error_code(Error::badDerEncoding);
                    return;
                }
            }
        }

        v = bits;
    }
};

/** wrapper class for coding c++ collections as ans.1 sets

    @see {@link #SequenceWrapper} for the wrapper for sequences
    @see {@link #make_set} for the convenience factory function

    @note There are two types of collections in ans.1 - sets and sequences.
          Given a c++ collection - i.e. a std::vector - the coders need to know
          if the collection should be coded as a set or a sequence. This class
          is the way to tell the coder which collection to use.
 */
template <class T>
struct SetOfWrapper
{
    using value_type = typename T::value_type;

    T& col_;
    SetOfWrapper(T& col) : col_(col)
    {
    }
};

/** wrapper class for coding c++ collections as ans.1 sets

    @see {@link #make_sequence} for the convenience factory function
    @see {@link #SetOfWrapper} for the wrapper for sets

    @note There are two types of collections in ans.1 - sets and sequences.
          Given a c++ collection - i.e. a std::vector - the coders need to know
          if the collection should be coded as a set or a sequence. This class
          is the way to tell the coder which collection to use.
 */
template <class T>
struct SequenceOfWrapper
{
    /** the collection being wrapped

       @note col_ may be a homogeneous collection like vector or a heterogeneous
             collection like tuple
    */
    T& col_;
    SequenceOfWrapper(T& col) : col_(col)
    {
    }
};

/// convenience function to wrap a c++ collection as it will be coded as an asn.1 set
template <class T>
SetOfWrapper<T>
make_set(T& t)
{
    return SetOfWrapper<T>(t);
}

/// convenience function to wrap a c++ collection as it will be coded as an asn.1 sequence
template <class T>
auto
make_sequence(T& t)
{
    return SequenceOfWrapper<T>(t);
}

/// convenience function to wrap a c++ tuple as it will be coded as an asn.1 sequence
template <class... T>
auto
make_sequence(std::tuple<T...>& t)
{
    return SequenceOfWrapper<std::tuple<T...>>(t);
}

/** DerCoderTraits for types that will be coded as asn.1 sets

    @see {@link #DerCoderTraits}
    @see {@link #make_set}
    @see {@link #SetOfWrapper}
*/
template <class T>
struct DerCoderTraits<SetOfWrapper<T>>
{
    constexpr static GroupType
    groupType()
    {
        return GroupType::set;
    }

    constexpr static ClassId
    classId()
    {
        return ClassId::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{17};
        return tn;
    }
    static std::uint8_t
    tagNum(SetOfWrapper<T> const&)
    {
        return 17;
    }
    constexpr static bool
    primitive()
    {
        return false;
    }

    static void
    encode(Encoder& encoder, SetOfWrapper<T> const& v)
    {
        for (auto const& e : v.col_)
            encoder << e;
    }

    static void
    decode(Decoder& decoder, SetOfWrapper<T>& v)
    {
        v.col_.clear();

        auto& slice = decoder.parentSlice();

        while (!slice.empty())
        {
            typename T::value_type val;
            decoder >> val;
            v.col_.emplace_back(std::move(val));
            if (decoder.ec())
                return;
        }
    }
};

/** DerCoderTraits for types that will be coded as asn.1 sequences

    @see {@link #DerCoderTraits}
    @see {@link #make_sequence}
    @see {@link #SequenceOfWrapper}
*/
template <class T>
struct DerCoderTraits<SequenceOfWrapper<T>>
{
    constexpr static GroupType
    groupType()
    {
        return GroupType::sequence;
    }

    constexpr static ClassId
    classId()
    {
        return ClassId::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{16};
        return tn;
    }
    static std::uint8_t
    tagNum(SequenceOfWrapper<T> const&)
    {
        return 16;
    }
    constexpr static bool
    primitive()
    {
        return false;
    }

    static void
    encode(Encoder& encoder, SequenceOfWrapper<T> const& v)
    {
        for (auto const& e : v.col_)
            encoder << e;
    }

    static void
    decode(Decoder& decoder, SequenceOfWrapper<T>& v)
    {
        v.col_.clear();

        auto& slice = decoder.parentSlice();

        while (!slice.empty())
        {
            typename T::value_type val;
            decoder >> val;
            v.col_.emplace_back(std::move(val));
            if (decoder.ec())
                return;
        }
    }
};

/** DerCoderTraits for std::tuples

    @note tuples will be decoded as ans.1 sequences

    @see {@link #DerCoderTraits}
*/
template <class... Ts>
struct DerCoderTraits<std::tuple<Ts&...>>
{
    using Tuple = std::tuple<Ts&...>;

    constexpr static GroupType
    groupType()
    {
        return GroupType::autoSequence;
    }

    constexpr static ClassId
    classId()
    {
        return ClassId::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{16};
        return tn;
    }

    static std::uint8_t
    tagNum(Tuple const&)
    {
        return 16;
    }
    constexpr static bool
    primitive()
    {
        return false;
    }

    template <std::size_t... Is>
    static void
    encodeElementsHelper(
        Encoder& encoder,
        Tuple const& elements,
        std::index_sequence<Is...>)
    {
        // Sean Parent for_each_argument trick (C++ fold expressions would be
        // nice here)
        (void)std::array<int, sizeof...(Ts)>{
            {((encoder << std::get<Is>(elements)), 0)...}};
    }

    template <std::size_t... Is>
    static void
    decodeElementsHelper(
        Decoder& decoder,
        Tuple const& elements,
        std::index_sequence<Is...>)
    {
        // Sean Parent for_each_argument trick (C++ fold expressions would be
        // nice here)
        (void)std::array<int, sizeof...(Ts)>{
            {((decoder >> std::get<Is>(elements)), 0)...}};
    }

    static void
    encode(Encoder& encoder, Tuple const& elements)
    {
        encodeElementsHelper(
            encoder, elements, std::index_sequence_for<Ts...>{});
    }

    static void
    decode(Decoder& decoder, Tuple const& elements)
    {
        decodeElementsHelper(
            decoder, elements, std::index_sequence_for<Ts...>{});
    }
};

}  // der
}  // cryptoconditions
}  // ripple

#endif
