//------------------------------------------------------------------------------
/*
    This file is part of rippled: https://github.com/ripple/rippled
    Copyright (c) 2017 Ripple Labs Inc.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose  with  or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE  SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH  REGARD  TO  THIS  SOFTWARE  INCLUDING  ALL  IMPLIED  WARRANTIES  OF
    MERCHANTABILITY  AND  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY  SPECIAL ,  DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER  RESULTING  FROM  LOSS  OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION  OF  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/
//==============================================================================

#ifndef RIPPLE_CONDITIONS_DER_H
#define RIPPLE_CONDITIONS_DER_H

#include <ripple/basics/Buffer.h>
#include <ripple/basics/Slice.h>
#include <ripple/conditions/Types.h>

#include <algorithm>
#include <bitset>
#include <limits>
#include <stack>
#include <system_error>
#include <vector>

#include <boost/optional.hpp>

namespace ripple {
namespace cryptoconditions {
namespace der {

// Type of the group. Sometimes this matches the tag number, but not always. In
// particular, a coder in "auto" mode may use different tags, and some of these
// types (`autoSequence`, `sequenceChild`, `choice`, and `fuzzRoot`) will never
// match the tag type. However, the coders need to know the additional
// information, such as when the parent group is a sequence, or an autoSequence.

enum class GroupType {
    boolean = 1,
    integer = 2,
    bitString = 3,
    octetString = 4,
    null = 5,
    objectIdentifier = 6,
    real = 9,
    enumerated = 10,
    utf8String = 12,
    sequence = 16,
    set = 17,

    // The following are never tag ids.

    // a sequence that has auto generated tag numbers
    autoSequence = 252,
    // a child in an autogenerated sequence. This is useful as the parent when
    // the child is a "choice"
    sequenceChild = 253,
    choice = 254,
    // used in fuzz testing only
    fuzzRoot = 255
};

enum class Error {
    /// a decoded integer would not fit in the bounds of the specified type
    integerBounds = 1,
    /// there is more content data in a group than expected
    longGroup,
    /// there is less content data in a group than expected
    shortGroup,
    /// encoding is not a valid der encoding
    badDerEncoding,
    /// this implementation only supports tag numbers up to the largest
    /// std::uint64_t
    tagOverflow,
    /// a decoded preamble did not match an expected preamble
    preambleMismatch,
    /// a decoded contentLength did not match an expected contentLength
    contentLengthMismatch,
    /// choice tag did not match a known type
    unknownChoiceTag,
    /// supported by der, but not this implementation
    unsupported,
    /// logicError
    logicError
};

std::error_code
make_error_code(Error e);

/// class id
enum class cid { universal, application, contextSpecific, priv };

enum class TagMode {
    direct /*explicit, but that is a c++ keyword*/,
    automatic
};

struct Encoder;
struct Decoder;

/*
  Types that serialized into a der coder need to specialize a `DerCoderTraits`
  class and provide implementations of each of the member functions described in
  this unspecialized class
 */
template <class T>
struct DerCoderTraits
{
    static_assert(
        sizeof(T) == -1,
        "DerCoderTraits must be specialized for this type");

    constexpr static cid
    classId();

    constexpr static GroupType
    groupType();

    static boost::optional<std::uint8_t> const&
    tagNum();

    template <class TT>
    static std::uint8_t tagNum(TT);

    constexpr static bool
    primitive();

    template <class TT>
    static size_t
    length(TT const& v);

    template <class TT>
    static void
    encode(Encoder& s, TT v);

    template <class TT>
    static void
    decode(Decoder& decoder, TT& v);
};

struct SequenceTag
{
};
struct SetTag
{
};

struct Tag
{
    cid classId = cid::universal;
    std::uint64_t tagNum = 0;
    bool primitive = true;

    Tag() = default;
    Tag(Type t);

    Tag(cid classId_, std::uint64_t tagNum_, bool primitive_)
        : classId(classId_), tagNum(tagNum_), primitive(primitive_)
    {
    }

    template <class T>
    Tag(DerCoderTraits<T> t, std::uint64_t tn)
        : Tag(DerCoderTraits<T>::classId(), tn, DerCoderTraits<T>::primitive())
    {
    }

    Tag(SequenceTag);

    Tag(SetTag);

    bool
    isSet() const;

    friend bool
    operator<(Tag const& lhs, Tag const& rhs)
    {
        return std::tie(lhs.classId, lhs.tagNum, lhs.primitive) <
            std::tie(rhs.classId, rhs.tagNum, rhs.primitive);
    }
    friend bool
    operator==(Tag const& lhs, Tag const& rhs)
    {
        return lhs.classId == rhs.classId && lhs.tagNum == rhs.tagNum &&
            lhs.primitive == rhs.primitive;
    }
    friend bool
    operator!=(Tag const& lhs, Tag const& rhs)
    {
        return !operator==(lhs, rhs);
    }
};

struct Preamble
{
    Tag tag_;
    size_t contentLength_;
};

struct Encoder;
template <class Coder>
class GroupGuard
{
    Coder& s_;

public:
    explicit GroupGuard(Coder& s, Tag t, GroupType bt) : s_(s)
    {
        s_.startGroup(t, bt);
    }

    explicit GroupGuard(Coder& s, boost::optional<Tag> const& t, GroupType bt)
        : s_(s)
    {
        s_.startGroup(t, bt);
    }

    explicit GroupGuard(Coder& s, SequenceTag t)
        : GroupGuard(s, Tag{t}, GroupType::sequence)
    {
    }

    explicit GroupGuard(Coder& s, SetTag t)
        : GroupGuard(s, Tag{t}, GroupType::set)
    {
    }

    template <class T>
    explicit GroupGuard(Coder& s, DerCoderTraits<T> t) : s_(s)
    {
        boost::optional<Tag> tag;
        if (auto const tagNum = t.tagNum())
            tag.emplace(t, *tagNum);
        s_.startGroup(tag, t.groupType());
    }

    template <class T>
    explicit GroupGuard(Coder& s, T const& v, DerCoderTraits<T> t) : s_(s)
    {
        auto const tagNum = t.tagNum(v);
        Tag tag(t, tagNum);
        s_.startGroup(tag, t.groupType());
    }

    // Needed for fuzz testing
    explicit GroupGuard(Coder& s, GroupType bt) : s_(s)
    {
        s_.startGroup(boost::none, bt);
    }

    ~GroupGuard()
    {
        s_.endGroup();
    }
};

template <class Coder>
class EosGuard
{
    Coder& s_;

public:
    explicit EosGuard(Coder& s) : s_(s)
    {
    }

    ~EosGuard()
    {
        s_.eos();
    }
};

// Encode the integer in big endian form, in as few of bytes as possible. All
// but the last byte has the high order bit set. The number is encoded in base
// 128 (7-bits each).
void
encodeTagNum(std::vector<char>& dst, std::uint64_t v);

// Encode the integer in big endian form, in as few of bytes as possible.
void
encodeContentLength(std::vector<char>& dst, std::uint64_t v);

class Group
{
    Tag id_;
    std::size_t start_;
    std::size_t end_;
    std::vector<Group> children_;
    std::vector<char> preamble_;
    TagMode tagMode_;
    GroupType groupType_;

    // Set must be output in sorted order. When serializing the children of a
    // group that represents a set, the serialization will be cached. Since Sets
    // can have children that are also sets, this prevents serializing the
    // "leaf" sets multiple times.
    mutable std::vector<char> cache_;
    std::vector<char>&
    cache(std::vector<char> const& src) const;

public:
    Group(Group const&) = default;
    Group(Group&&) = default;
    Group&
    operator=(Group&&) = default;
    Group&
    operator=(Group const&) = default;

    Group(
        Tag t,
        std::size_t s,
        TagMode tagMode,
        GroupType groupType);

    size_t
    childPreambleSize() const;

    size_t
    totalPreambleSize() const;

    size_t
    start() const;

    size_t
    end() const;

    void
    end(std::size_t e);

    size_t
    size() const;

    void
    calcPreamble();

    void
    write(std::vector<char> const& src, std::vector<char>& dst) const;

    template <class... C>
    void
    emplaceChild(C&&... c)
    {
        children_.emplace_back(std::forward<C>(c)...);
    }

    bool
    isSet() const;

    bool
    isAutoSequence() const;

    bool
    isChoice() const;

    void
    setPrimitiveAndType(bool primitive, GroupType bt);

    size_t
    numChildren() const;
};

void
encodePreamble(std::vector<char>& dst, Preamble const& p);

void
decodePreamble(Slice& slice, Preamble& p, std::error_code& ec);

struct Eos
{
};
extern Eos eos;
struct Automatic
{
};
extern Automatic automatic;
struct Constructor
{
};
extern Constructor constructor;

struct Encoder
{
    TagMode tagMode_ = TagMode::direct;
    std::vector<char> buf_;
    std::stack<Group> subgroups_;
    std::vector<Group> roots_;

    std::error_code ec_;
    bool atEos_ = false;

    explicit Encoder(TagMode tagMode);
    ~Encoder();

    void
    startGroup(Tag t, GroupType groupType);

    void
    endGroup();

    void
    eos();

    // total size of the content and all the preambles
    size_t
    size() const;

    std::error_code const&
    ec() const;

    void
    write(std::vector<char>& dst) const;

    bool
    parentIsAutoSequence() const;

    bool
    parentIsChoice() const;

    friend Encoder& operator&(Encoder& s, Preamble const& p)
    {
        encodePreamble(s.buf_, p);
        return s;
    }
    friend Encoder& operator&(Encoder& s, Preamble& p)
    {
        encodePreamble(s.buf_, p);
        return s;
    }

    friend Encoder& operator&(Encoder& s, Eos e)
    {
        s.eos();
        return s;
    }

    template <class T>
    friend Encoder& operator&(Encoder& s, T&& v)
    {
        if (s.ec_)
            return s;

        using traits = DerCoderTraits<std::decay_t<T>>;
        auto const groupType = traits::groupType();

        if (s.parentIsAutoSequence())
        {
            if (groupType == GroupType::choice)
            {
                Tag const tag1{cid::contextSpecific,
                               s.subgroups_.top().numChildren(),
                               traits::primitive()};
                GroupGuard<Encoder> g1(s, tag1, GroupType::sequenceChild);
                if (s.ec_)
                    return s;
                Tag const tag2{traits{}, traits::tagNum(v)};
                GroupGuard<Encoder> g2(s, tag2, groupType);
                if (s.ec_)
                    return s;
                traits::encode(s, std::forward<T>(v));
            }
            else
            {
                Tag const tag{cid::contextSpecific,
                              s.subgroups_.top().numChildren(),
                              traits::primitive()};
                GroupGuard<Encoder> g(s, tag, groupType);
                if (s.ec_)
                    return s;
                traits::encode(s, std::forward<T>(v));
            }
        }
        else
        {
            Tag const tag{traits{}, traits::tagNum(v)};
            GroupGuard<Encoder> g(s, tag, groupType);
            if (s.ec_)
                return s;
            traits::encode(s, std::forward<T>(v));
        }

        return s;
    }

    template <class T>
    friend Encoder&
    operator<<(Encoder& s, T&& t)
    {
        return s & std::forward<T>(t);
    }
};

struct Decoder
{
    TagMode tagMode_;
    bool atEos_ = false;

    Slice rootSlice_;
    // slice, ancestor tag, groupType, and number of children
    std::stack<std::tuple<Slice, Tag, GroupType, std::uint32_t>> ancestors_;

    std::error_code ec_;

    Decoder() = delete;
    explicit Decoder(Slice slice, TagMode tagMode);
    ~Decoder();

    void
    startGroup(boost::optional<Tag> const& t, GroupType groupType);

    void
    endGroup();

    void
    eos();

    std::error_code const&
    ec() const;

    boost::optional<Tag>
    parentTag() const;

    bool
    parentIsAutoSequence() const;

    bool
    parentIsChoice() const;

    Slice&
    parentSlice();

    friend Decoder& operator&(Decoder& s, Eos e)
    {
        s.eos();
        return s;
    }

    friend Decoder& operator&(Decoder& s, Preamble& p)
    {
        if (s.ec_)
            return s;

        decodePreamble(s.parentSlice(), p, s.ec_);
        return s;
    }

    // The forwarding ref is needed here to support std::tie, SetWrapper, and
    // SequenceWrapper
    // (i.e. `s >> make_set(some_vec)`)
    template <class T>
    friend Decoder& operator&(Decoder& s, T&& v)
    {
        if (s.ec_)
            return s;

        using traits = DerCoderTraits<std::decay_t<T>>;
        auto const groupType = traits::groupType();
        if (s.parentIsAutoSequence())
        {
            if (groupType == GroupType::choice)
            {
                auto& numChildren = std::get<std::uint32_t>(s.ancestors_.top());
                Tag const tag1{
                    cid::contextSpecific, numChildren++, traits::primitive()};
                GroupGuard<Decoder> g1(s, tag1, GroupType::sequenceChild);
                if (s.ec_)
                    return s;
                boost::optional<Tag> tag2;
                if (auto const tagNum = traits::tagNum())
                    tag2.emplace(traits{}, *tagNum);
                GroupGuard<Decoder> g2(s, tag2, groupType);
                if (s.ec_)
                    return s;
                traits::decode(s, v);
            }
            else
            {
                auto& numChildren = std::get<std::uint32_t>(s.ancestors_.top());
                Tag const tag{
                    cid::contextSpecific, numChildren++, traits::primitive()};
                GroupGuard<Decoder> g(s, tag, groupType);
                if (s.ec_)
                    return s;
                traits::decode(s, v);
            }
        }
        else
        {
            boost::optional<Tag> tag;
            if (auto const tagNum = traits::tagNum())
                tag.emplace(traits{}, *tagNum);
            GroupGuard<Decoder> g(s, tag, groupType);
            if (s.ec_)
                return s;
            traits::decode(s, v);
        }

        return s;
    }

    template <class T>
    friend Decoder&
    operator>>(Decoder& s, T&& t)
    {
        return s & std::forward<T>(t);
    }

    void
    fuzzTest();
};

struct IntegerTraits
{
    constexpr static cid
    classId()
    {
        return cid::universal;
    }

    constexpr static GroupType
    groupType()
    {
        return GroupType::integer;
    }

    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{2};
        return tn;
    }

    template <class T>
    static std::uint8_t tagNum(T)
    {
        return 2;
    }

    constexpr static bool
    primitive()
    {
        return true;
    }

    template <class T>
    static size_t
    length(T const& v)
    {
        const auto isSigned = std::numeric_limits<T>::is_signed;
        if (!v || (isSigned && v == -1))
            return 1;

        std::size_t n = sizeof(v);
        signed char toSkip = (isSigned && v < 0) ? 0xff : 0;
        // skip leading 0xff for negative signed, otherwise skip leading zeros
        // when skipping 0xff, the next octet's high bit must be set
        // when skipping 0, the first octet's high bit must not be set
        while (n--)
        {
            auto const c = static_cast<signed char>((v >> (n * 8)) & 0xff);
            if (c == toSkip &&
                !(isSigned && v < 0 && n &&
                  (static_cast<signed char>((v >> ((n - 1) * 8)) & 0xff) >= 0)))
                continue;

            if (v > 0 && c < 0)
                return n + 2;
            else
                return n + 1;
        }
        assert(0);  // will never happen
        return 1;
    }

    template <class T>
    static void
    encode(Encoder& s, T v)
    {
        std::vector<char>& dst = s.buf_;

        if (!v)
        {
            dst.push_back(0);
            return;
        }

        std::size_t n = length(v);
        while (n--)
        {
            if (n >= sizeof(T))
                dst.push_back(static_cast<char>(0));
            else
                dst.push_back(static_cast<char>((v >> (n * 8)) & 0xFF));
        }
    }

    template <class T>
    static void
    decode(Decoder& decoder, T& v)
    {
        auto& slice = decoder.parentSlice();
        std::error_code& ec = decoder.ec_;

        if (slice.empty())
        {
            // can never have zero sized integers
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        const bool isSigned = std::numeric_limits<T>::is_signed;
        // unsigned types may have a leading zero octet
        const size_t maxLength = isSigned ? sizeof(T) : sizeof(T) + 1;
        if (slice.size() > maxLength)
        {
            ec = make_error_code(Error::integerBounds);
            return;
        }

        if (!isSigned && (slice[0] & (1 << 7)))
        {
            // trying to decode a negative number into a positive value
            ec = make_error_code(Error::integerBounds);
            return;
        }

        if (!isSigned && slice.size() == sizeof(T) + 1 && slice[0])
        {
            // since integers are coded as two's complement, the first byte may
            // be zero for unsigned reps
            ec = make_error_code(Error::integerBounds);
            return;
        }

        v = 0;
        for (size_t i = 0; i < slice.size(); ++i)
            v = (v << 8) | (slice[i] & 0xff);

        if (isSigned && (slice[0] & (1 << 7)))
        {
            for (int i = slice.size(); i < sizeof(T); ++i)
                v |= (T(0xff) << (8 * i));
        }
        slice += slice.size();
    }
};

template <>
struct DerCoderTraits<std::uint8_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::uint16_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::uint32_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::uint64_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int8_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int16_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int32_t> : IntegerTraits
{
};
template <>
struct DerCoderTraits<std::int64_t> : IntegerTraits
{
};

struct OctetStringTraits
{
    constexpr static cid
    classId()
    {
        return cid::universal;
    }

    constexpr static GroupType
    groupType()
    {
        return GroupType::octetString;
    }

    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{4};
        return tn;
    }

    template <class T>
    static std::uint8_t
    tagNum(T const&)
    {
        return 4;
    }

    constexpr static bool
    primitive()
    {
        return true;
    }

protected:
    static void
    encode(Encoder& encoder, Slice s)
    {
        if (s.empty())
            return;

        std::vector<char>& dst = encoder.buf_;

        auto const dstIdx = dst.size();
        dst.resize(dst.size() + s.size());
        memcpy(&dst[dstIdx], s.data(), s.size());
    }

    static void
    decode(Decoder& decoder, void* dstData, std::size_t dstSize)
    {
        auto& slice = decoder.parentSlice();
        std::error_code& ec = decoder.ec_;

        if (dstSize != slice.size())
        {
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        if (!slice.empty())
            memcpy(dstData, slice.data(), slice.size());

        slice += slice.size();
    }
};

template <>
struct DerCoderTraits<std::string> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, std::string const& s)
    {
        OctetStringTraits::encode(encoder, makeSlice(s));
    }

    static void
    decode(Decoder& decoder, std::string& v)
    {
        auto& slice = decoder.parentSlice();
        v.resize(slice.size());
        if (!v.empty())
            OctetStringTraits::decode(decoder, &v[0], v.size());
    }
};

template <std::size_t S>
struct DerCoderTraits<std::array<std::uint8_t, S>> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, std::array<std::uint8_t, S> const& s)
    {
        OctetStringTraits::encode(encoder, makeSlice(s));
    }

    static void
    decode(Decoder& decoder, std::array<std::uint8_t, S>& v)
    {
        OctetStringTraits::decode(decoder, v.data(), v.size());
    }
};

template <>
struct DerCoderTraits<Buffer> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, Buffer const& b)
    {
        OctetStringTraits::encode(encoder, b);
    }

    static void
    decode(Decoder& decoder, Buffer& v)
    {
        auto& slice = decoder.parentSlice();
        v.alloc(slice.size());
        if (!v.empty())
            OctetStringTraits::decode(decoder, v.data(), v.size());
    }
};

// Wrapper for a size constrained der OctetString
template <class T>
struct OctetStringCheckEqualSize
{
    T& col_;
    std::size_t constraint_;
    OctetStringCheckEqualSize(T& col, std::size_t s) : col_{col}, constraint_{s}
    {
    }
};

template <class T>
struct OctetStringCheckLessSize
{
    T& col_;
    std::size_t constraint_;
    OctetStringCheckLessSize(T& col, std::size_t s) : col_{col}, constraint_{s}
    {
    }
};

template <class T>
OctetStringCheckEqualSize<T>
make_octet_string_check_equal(T& t, std::size_t s)
{
    return OctetStringCheckEqualSize<T>(t, s);
}

template <class T>
OctetStringCheckLessSize<T>
make_octet_string_check_less(T& t, std::size_t s)
{
    return OctetStringCheckLessSize<T>(t, s);
}

template <class T>
struct DerCoderTraits<OctetStringCheckEqualSize<T>> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, OctetStringCheckEqualSize<T> const& v)
    {
        DerCoderTraits<T>::encode(encoder, v.col_);
    }

    static void
    decode(Decoder& decoder, OctetStringCheckEqualSize<T>& v)
    {
        auto& slice = decoder.parentSlice();
        if (slice.size() != v.constraint_)
        {
            decoder.ec_ = make_error_code(Error::contentLengthMismatch);
            return;
        }
        DerCoderTraits<T>::decode(decoder, v.col_);
    }
};

template <class T>
struct DerCoderTraits<OctetStringCheckLessSize<T>> : OctetStringTraits
{
    static void
    encode(Encoder& encoder, OctetStringCheckLessSize<T> const& v)
    {
        DerCoderTraits<T>::encode(encoder, v.col_);
    }

    static void
    decode(Decoder& decoder, OctetStringCheckLessSize<T>& v)
    {
        auto& slice = decoder.parentSlice();
        if (slice.size() > v.constraint_)
        {
            decoder.ec_ = make_error_code(Error::unsupported);
            return;
        }
        DerCoderTraits<T>::decode(decoder, v.col_);
    }
};

template <std::size_t S>
struct DerCoderTraits<std::bitset<S>>
{
    constexpr static std::uint8_t mod8 = S % 8;
    constexpr static std::uint8_t const minUnusedBits = mod8 ? 8 - mod8 : 0;
    constexpr static std::uint8_t const maxBytes = mod8 ? 1 + S / 8 : S / 8;

    constexpr static GroupType
    groupType()
    {
        return GroupType::bitString;
    }

    constexpr static cid
    classId()
    {
        return cid::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{3};
        return tn;
    }
    static std::uint8_t
    tagNum(std::bitset<S> const&)
    {
        return 3;
    }
    constexpr static bool
    primitive()
    {
        return true;
    }

    static std::uint8_t
    reverseBits(std::uint8_t b)
    {
        static constexpr std::uint8_t lut[256] = 
        {
          0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 
          0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 
          0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 
          0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 
          0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2, 
          0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
          0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 
          0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
          0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
          0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 
          0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
          0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
          0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 
          0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
          0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 
          0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
        };
        return lut[b];
    }

    static void
    encode(Encoder& encoder, std::bitset<S> const& s)
    {
        std::vector<char>& dst = encoder.buf_;
        dst.reserve(
            dst.size() + 1 + maxBytes);  // +1 for encoding the unusedBits

        static_assert(
            maxBytes > 0 && maxBytes <= sizeof(unsigned long),
            "Unsupported bitset size");
        auto const bits = s.to_ulong();

        if (bits == 0)
        {
            dst.push_back(7);
            dst.push_back(0);
            return;
        }

        std::size_t const leadingZeroBytes = [&] {
            std::size_t result = 0;
            auto curByteIndex = maxBytes;
            while (curByteIndex--)
            {
                std::uint8_t const b = (bits >> curByteIndex * 8) & 0xff;
                if (b)
                    return result;
                ++result;
            }
            return result;
        }();

        std::uint8_t const unusedBits = [&] {
            // b is first non-zero byte
            std::uint8_t const b =
                (bits >> (maxBytes - leadingZeroBytes - 1) * 8) & 0xff;
            if (b & 0x80)
                return 0;
            if (b & 0x40)
                return 1;
            if (b & 0x20)
                return 2;
            if (b & 0x10)
                return 3;
            if (b & 0x08)
                return 4;
            if (b & 0x04)
                return 5;
            if (b & 0x02)
                return 6;
            if (b & 0x01)
                return 7;
            return 8;
        }();

        dst.push_back(unusedBits);

        for (size_t curByte = 0; curByte < maxBytes - leadingZeroBytes; ++curByte)
        {
            uint8_t const v = (bits >> curByte * 8) & 0xff;
            dst.push_back(reverseBits(v));
        }
    }

    static void
    decode(Decoder& decoder, std::bitset<S>& v)
    {
        auto& slice = decoder.parentSlice();
        std::error_code& ec = decoder.ec_;

        if (slice.size() > maxBytes + 1)
        {
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        auto const unused = slice[0];
        slice += 1;

        if (unused < minUnusedBits)
        {
            ec = make_error_code(Error::contentLengthMismatch);
            return;
        }

        if (unused >= 8)
        {
            ec = make_error_code(Error::badDerEncoding);
            return;
        }

        static_assert(
            maxBytes > 0 && maxBytes <= sizeof(unsigned long),
            "Unsupported bitset size");
        unsigned long bits = 0;
        auto const numBytes = slice.size();
        for (size_t curByteIndex = 0; curByteIndex < numBytes; ++curByteIndex)
        {
            std::uint8_t const curByte = reverseBits(slice[0]);
            bits |= curByte << (curByteIndex * 8);
            slice += 1;

            if ((curByteIndex == numBytes - 1) && unused)
            {
                // check last byte for correct zero padding
                std::uint8_t const mask = 0xff & ~((1 << (8 - unused)) - 1);
                if (curByte & mask)
                {
                    // last byte has incorrect padding
                    ec = make_error_code(Error::badDerEncoding);
                    return;
                }
            }
        }

        v = bits;
    }
};

// Wrapper for a der set of T
template <class T>
struct SetOfWrapper
{
    using value_type = typename T::value_type;

    T& col_;
    SetOfWrapper(T& col) : col_(col)
    {
    }
};

// Wrapper for a der sequence of T
template <class T>
struct SequenceOfWrapper
{
    // col_ may be a homogeneous collection like vector or a heterogeneous
    // collection like tuple
    T& col_;
    SequenceOfWrapper(T& col) : col_(col)
    {
    }
};

template <class T>
SetOfWrapper<T>
make_set(T& t)
{
    return SetOfWrapper<T>(t);
}

template <class T>
auto
make_sequence(T& t)
{
    return SequenceOfWrapper<T>(t);
}

template <class... T>
auto
make_sequence(std::tuple<T...>& t)
{
    return SequenceOfWrapper<std::tuple<T...>>(t);
}

template <class T>
struct DerCoderTraits<SetOfWrapper<T>>
{
    constexpr static GroupType
    groupType()
    {
        return GroupType::set;
    }

    constexpr static cid
    classId()
    {
        return cid::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{17};
        return tn;
    }
    static std::uint8_t
    tagNum(SetOfWrapper<T> const&)
    {
        return 17;
    }
    constexpr static bool
    primitive()
    {
        return false;
    }

    static void
    encode(Encoder& encoder, SetOfWrapper<T> const& v)
    {
        for (auto const& e : v.col_)
            encoder << e;
    }

    static void
    decode(Decoder& decoder, SetOfWrapper<T>& v)
    {
        v.col_.clear();

        auto& slice = decoder.parentSlice();

        while (!slice.empty())
        {
            typename T::value_type val;
            decoder >> val;
            v.col_.emplace_back(std::move(val));
            if (decoder.ec())
                return;
        }
    }
};

template <class T>
struct DerCoderTraits<SequenceOfWrapper<T>>
{
    constexpr static GroupType
    groupType()
    {
        return GroupType::sequence;
    }

    constexpr static cid
    classId()
    {
        return cid::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{16};
        return tn;
    }
    static std::uint8_t
    tagNum(SequenceOfWrapper<T> const&)
    {
        return 16;
    }
    constexpr static bool
    primitive()
    {
        return false;
    }

    static void
    encode(Encoder& encoder, SequenceOfWrapper<T> const& v)
    {
        for (auto const& e : v.col_)
            encoder << e;
    }

    static void
    decode(Decoder& decoder, SequenceOfWrapper<T>& v)
    {
        v.col_.clear();

        auto& slice = decoder.parentSlice();

        while (!slice.empty())
        {
            typename T::value_type val;
            decoder >> val;
            v.col_.emplace_back(std::move(val));
            if (decoder.ec())
                return;
        }
    }
};

template <class... Ts>
struct DerCoderTraits<std::tuple<Ts&...>>
{
    using Tuple = std::tuple<Ts&...>;

    constexpr static GroupType
    groupType()
    {
        return GroupType::autoSequence;
    }

    constexpr static cid
    classId()
    {
        return cid::universal;
    }
    static boost::optional<std::uint8_t> const&
    tagNum()
    {
        static boost::optional<std::uint8_t> tn{16};
        return tn;
    }

    static std::uint8_t
    tagNum(Tuple const&)
    {
        return 16;
    }
    constexpr static bool
    primitive()
    {
        return false;
    }

    template <std::size_t... Is>
    static void
    encodeElementsHelper(
        Encoder& encoder,
        Tuple const& elements,
        std::index_sequence<Is...>)
    {
        // Sean Parent for_each_argument trick (C++ fold expressions would be
        // nice here)
        (void)std::array<int, sizeof...(Ts)>{
            {((encoder << std::get<Is>(elements)), 0)...}};
    }

    template <std::size_t... Is>
    static void
    decodeElementsHelper(
        Decoder& decoder,
        Tuple const& elements,
        std::index_sequence<Is...>)
    {
        // Sean Parent for_each_argument trick (C++ fold expressions would be
        // nice here)
        (void)std::array<int, sizeof...(Ts)>{
            {((decoder >> std::get<Is>(elements)), 0)...}};
    }

    static void
    encode(Encoder& encoder, Tuple const& elements)
    {
        encodeElementsHelper(
            encoder, elements, std::index_sequence_for<Ts...>{});
    }

    static void
    decode(Decoder& decoder, Tuple const& elements)
    {
        decodeElementsHelper(
            decoder, elements, std::index_sequence_for<Ts...>{});
    }
};

}  // der
}  // cryptoconditions
}  // ripple

#endif
